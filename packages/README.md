# What is this directory?

Packages are self contained, modular, closed, optionally dependent code-packages
for a specific map detail (eg. Heightmap, Grid, Windrose, States or Roads).

They are:

- *Self contained* as they include the data model, data access API,
  data modification API, generation algorithm, render algorithm,
  generator UI and modification UI in a single package.
- *Modular* as they must obey specific rules and have some particular structure
  (implement a Package interface). Thanks to this, they are interchangable.
- *Closed* as they expose a specific API (interface) for other Packages.
  Implementation details and (most of the) data structure is kept private.
- *Optionally dependent* as packages may depend on other packages' data
  (eg. Road on Heightmap) but some dependencies can be optional.

# Package Interface

All packages must include an _info.js file read by the package manager
for further information. (Underscore used for alphabetical ordering in the
directory). Active package directory names must be included in 'regsitry.js'.

_info.js must have a default export which is single object in the following form:
```
{
  name: String,         // short name of the package
  description: String,  // long description of the package
  generators: GenDescriptor[], // list of generator descriptors
  renderers: RdrDescriptor[],  // list of renderer descriptors
}
```

GenDescriptor structure:
```
{
  name: String, // short name (identifier) of the generator
  info: String, // description of the generator
  requires: DetailName[], // list of required detailnames eg. ['CellGrid']
  uses: DetailName[],     // list of optional detailnames
  provides: DetailName[], // list of provided detailnames ()
  src: Optional<Loc>, // source to include (defaults to generators/${name}.js)
  ui: Optional<Loc>,  // source of the ui to include (defaults to ui/${name}Conf.js)
}
```

Loc object defined by:
```
{
  include: Optional<String>, // module prop to use, defaults to 'default'
  from: Optional<String>,    // filename to include
}
```

RdrDescriptor structure:
```
{
  name: String, // short name (identifier) of the sub-renderer
  info: String, // description of the sub-renderer
  image: String, // target image type ("SVG", "JSON", ...)
  src: Optional<Loc>, // source to include (defaults to renderers/${name}.js)
  ui: Optional<Loc>,  // source of the ui to include (defaults to ui/${name}Render.js)
}
```

DetailName objects are simple strings, representing the required/provided
Interfaces.



## Legacy state generators

Legacy generators are not real "generators" in a sense they relay on existing
data structures (eg. grid or pack). They won't actually generate anything
merely provide the required interface for the particular package (MapDetail).


## Structures (data interfaces)

*DetailState*
: serializable class storing state of the particular Map Detail
  (eg. RoadState is a DetailState). Exposes detail-specific methods
  (the detail's API).

*MapState*
: Immutable, frozen set of DetailStates representing an actual map.
For performance reasons references to previous DetailState objects are allowed.
(Immutability guarantees there will be no unwanted side effects). Because
DetailStates (and hence MapState) can not be modified, map modifications
realized by creating new DetailStates using mutators (the Generators).

*GeneratorConfig*
: serializable dictionary object generated by the package's configurator UI
  and consumed by a detail generator.

*Generator*
: detail generators are factory functions returning list of standardized
DetailState objects (one or more). Generators accept a GeneratorContext  
(GeneratorConfig and a list of DetailStates (subset of the current MapState)).
Their type is:
`async GeneratorContext  => Set<DetailState>`
Generators must be deterministic and pure (shouldn't generate side effects).

*GeneratorContext*
: context for generators providing two important objects:
config: GeneratorConfig and states: Set<DetailState>

*GeneratorQueue*
: ordered list of generators, representing some specific Map-autogeneration
process. GeneratorQueue may be valid or invalid (decided by a checker) depending on
the order and required dependencies of the Generators used. Because generators
are pure, GeneratorQueue and the set of GeneratorConfigs used clearly define
any MapState (assuming no implementation change).

*MapStack*
Stack of (Generator, GeneratorConfig) tuples, representing different stages
of the map. Undo(/redo) can be implemented by popping layers from the stack.
For efficiency, MapStates of different stack levels can be cached.
MapStates can be (re)calculated as union of the latest active DetailStates.  


## Renderers

Concepcionally renderers are specialized Generators providing special
MapDetails, the Images. Image can be an SVG, PNG, Canvas or other representation
(view) of the given MapState. Renderer-generators may use many DetailStates
(usually a complete MapState) and provide single DetailState, the visual
represantion of the map (eg. an SVG node). Renderers don't have to be visuals
though, eg. a JSON exporter can be implemented as a renderer.

Renderers are special for two reasons:

1. They have access to other package's Renderer functions.
2. Their resulting DetailState (image)*can not be depend on*
  (except the generator itself, see below) therefore the image
  can be dropped from the MapStack at any time.

The 1st property is required for encapsulation and effeciency. Different packages
can provide their specialized detail-renderers for their own features (map detail).
Sub-renderers are collected by the Renderer-generator and used for actually
generating the Image (possibly on different layers).

Efficiency achieved by using both properties.
Renderer generators can reuse their previous state (this is the only allowed
dependency for Image-Detailstates) detect the difference between the two
MapStates (the change) and use the appropriate sub-generator to efficiently
regenerate subset of the Image. Change detection can be implemented as
input (GeneratorConfig) or using the Observer pattern.

Package provided sub-renderers (eg. an SVG renderer in the Road package) should
  have the following signature: `async render(SVGConfig, SVG, Set<DetailState>): SVG`
  where SVG is a specialization of DetailState.
